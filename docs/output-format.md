# C Output Format (Generated Artifacts)

This document describes the *structural* output format of the C code generated by
`emx-onnx-cgen` (the `compile` command). It focuses on the overall layout and the
stable public interface of the generated artifacts, not on individual operator
kernels.

Concrete examples of generated files live in [`tests/golden/`](../tests/golden/).

## Artifacts

Depending on CLI options, compilation can produce:

- `<out>.c`: main generated C translation unit (always).
- `<out>_data.c`: optional companion file containing constant data definitions
  (enabled by `--emit-data-file`).
- `<testbench>.c`: optional testbench translation unit when `--testbench-file`
  is set (implies `--emit-testbench`).
- `<model_name>.bin`: optional binary blob containing packed weights when
  `--large-weight-threshold` triggers.

Notes:

- `--model-name` controls the symbol prefix. If not specified, the output file
  stem is typically used.
- The file `<model_name>.bin` is written next to the main output C file.
- If `--testbench-file` is a relative path, it is resolved relative to the main
  output C file directory.

## High-Level File Layout

The generated `<out>.c` is intentionally self-contained and deterministic. It is
typically structured like the example below.

Operator code is emitted in a stable order (graph traversal order / node index),
and symbol names are derived deterministically from node indices and ONNX value
names (sanitized to C identifiers).

The following is an *illustrative* skeleton of a generated C file, with
irrelevant details omitted:

```c
/*
 * Generated by emmtrix ONNX-to-C Code Generator (emx-onnx-cgen)
 *
 * Codegen settings:
 *   emit_testbench: False
 *   restrict_arrays: True
 *   ...
 * Model checksum (sha256): <...>
 * Model name: <model_name>
 * Graph name: <...>
 * Inputs: <...> Outputs: <...> Nodes: <...> Initializers: <...>
 * Opset imports: ai.onnx=<...>
 */

// Minimal includes; the exact set depends on ops/options.
#include <stdint.h>
#include <math.h>
#include <float.h>
// Optional: <string.h>, <stdbool.h>, <stddef.h>, <stdio.h>, <ctype.h>, <strings.h>, ...

// Small configuration macros are emitted here.

// Scalar helpers used by kernels (pure functions).
static inline float ref_scalar_f32_relu(float a) { return a > 0.0f ? a : 0.0f; }

// Per-node kernels (static inline, explicit loops).
static inline void node0_relu(const float input0[1][16], float output[1][16]) {
    for (idx_t i0 = 0; i0 < 1; ++i0) {
        for (idx_t i1 = 0; i1 < 16; ++i1) {
            output[i0][i1] = ref_scalar_f32_relu(input0[i0][i1]);
        }
    }
}

// Weights/constants:
// - embedded constants: usually `static const ...`
// - external weights: global arrays populated by <model_name>_load()
static const float const0_bias[16] = { /* ... */ };

// Loader is always present; it may be a no-op if no external weights exist.
_Bool <model_name>_load(const char *path) {
    (void)path;
    return 1;
}

// Public entrypoint (mirrors ONNX IO); may include VLA dim args first.
void <model_name>(const float x[restrict 1][16], float y[restrict 1][16]) {
    // Temporaries are explicit (locals by default; may become `static` if large).
    node0_relu(x, y);
}
```

Optional testbench tail (emitted when `--emit-testbench` is enabled and
`--testbench-file` is not set):

```c
__attribute__((weak, noinline)) void timer_start(void) {}
__attribute__((weak, noinline)) void timer_stop(void) {}

static int testbench_run(const char *input_path) {
    // Allocate and initialize inputs (random or file-driven).
    // Allocate outputs.
    // If external weights exist, load them from "<model_name>.bin":
    if (!<model_name>_load("<model_name>.bin")) {
        return 1;
    }
    timer_start();
    <model_name>(/* dim args? */, /* inputs... */, /* outputs... */);
    timer_stop();
    // Print inputs/outputs as JSON (floats printed as hex via %a).
    testbench_print_json(/* inputs... */, /* outputs... */);
    return 0;
}

int main(int argc, char **argv) {
    const char *input_path = NULL;
    if (argc > 1) {
        input_path = argv[1];
    }
    return testbench_run(input_path);
}
```

When `--testbench-file <path>` is set, the testbench is emitted into a separate
translation unit instead of being appended to `<out>.c`. The separate file does
not include `<out>.c`; it contains forward declarations for `<model_name>()`
and `<model_name>_load()` and can be compiled and linked together with the main
output C file.

## Public C API

The public interface is intentionally small:

- `_Bool <model_name>_load(const char *path);`
- `void <model_name>(...inputs..., ...outputs...);`

### Example: Typical Call-Site

Static-shape model with embedded weights:

```c
#include <stdbool.h>

// Generated by emx-onnx-cgen:
_Bool model_load(const char *path);
void model(const float a[restrict 2][3][4],
           const float b[restrict 2][3][4],
           float out[restrict 2][3][4]);

int main(void) {
    // No external weights in this configuration; path is ignored.
    if (!model_load(NULL)) {
        return 1;
    }

    float a[2][3][4] = {0};
    float b[2][3][4] = {0};
    float out[2][3][4];

    model(a, b, out);
    return 0;
}
```

### `<model_name>_load`

The loader exists even if the model has no external weights.

- If no external weights are used, the loader typically ignores `path` and
  returns success.
- If external weights are used (`<model_name>.bin`), the loader reads weights
  from the given file path and initializes the generated weight arrays.

Design intent:

- Keep the "bring-up" surface minimal and auditable.
- Make weight initialization explicit, deterministic, and testable.

### `<model_name>` entrypoint

The entrypoint signature mirrors the ONNX graph IO:

- Each tensor IO becomes a parameter.
- Parameters are typed as N-dimensional C arrays (see [Tensor Representation](#tensor-representation)).
- When enabled, array parameters use `restrict` to help compilers optimize; this
  is controlled by `--no-restrict-arrays`.

Optional inputs:

- For an optional tensor input `x`, an additional `_Bool x_present` parameter is
  generated to indicate presence (see [`tests/golden/op_optionalhaselement_optional_has_element.c`](../tests/golden/op_optionalhaselement_optional_has_element.c)).

## Tensor Representation

### ONNX dtype to C type mapping

The generator supports a subset of ONNX tensor element types. The following
table summarizes how ONNX dtypes map to C types in the generated code, and which
ONNX dtypes are currently unsupported.

Notes:

- Fixed-width integer types use `<stdint.h>` (for example, `int32_t`).
- `bfloat16` uses `__bf16`; support depends on the target compiler/toolchain.
- `float16` uses C's `_Float16` type; support depends on the target compiler.
- `string` tensors are represented as fixed-size `'\0'`-terminated C strings
  (`char[EMX_STRING_MAX_LEN]` per element).

| ONNX dtype name | C type in generated code |
| --- | --- |
| bfloat16 | `__bf16` |
| float16 | `_Float16` |
| float | `float` |
| double | `double` |
| float8e4m3fn | not supported |
| float8e4m3fnuz | not supported |
| float8e5m2 | not supported |
| float8e5m2fnuz | not supported |
| float8e8m0 | not supported |
| float4e2m1 | not supported |
| int2 | not supported |
| int4 | not supported |
| int8 | `int8_t` |
| int16 | `int16_t` |
| int32 | `int32_t` |
| int64 | `int64_t` |
| uint2 | not supported |
| uint4 | not supported |
| uint8 | `uint8_t` |
| uint16 | `uint16_t` |
| uint32 | `uint32_t` |
| uint64 | `uint64_t` |
| bool | `bool` |
| string | `char[EMX_STRING_MAX_LEN]` |
| complex64 | not supported |
| complex128 | not supported |

### ONNX value types

The dtype table above only applies to `tensor_type` values (i.e. ONNX
`TypeProto.tensor_type`). ONNX also allows non-tensor value types such as
optionals and sequences.

The following table summarizes the supported ONNX value types and their C-level
representation in generated signatures:

| ONNX value type (TypeProto) | Example | C representation / support |
| --- | --- | --- |
| `tensor_type` | `tensor(float)` | Supported; represented as N-dimensional C arrays |
| `optional_type` | `optional(tensor(float))` | Supported for optional tensors; additional `_Bool <name>_present` parameter is added |
| `sequence_type` | `sequence(tensor(float))` | Supported at model IO ABI as fixed-capacity arrays plus count (`EMX_SEQUENCE_MAX_LEN`, `<name>__count`) |
| `map_type` | `map(string, tensor(float))` | Not supported |
| `sparse_tensor_type` | `sparse_tensor(float)` | Not supported |
| `opaque_type` | `opaque(...)` | Not supported |

For sequence tensor IO, generated model entrypoints use a fixed-capacity ABI:
- Input: `const T name[EMX_SEQUENCE_MAX_LEN][elem_shape...]` plus `idx_t name__count`.
- Output: `T name[EMX_SEQUENCE_MAX_LEN][elem_shape...]` plus `idx_t *name__count`.

### Static shapes: N-dimensional arrays

For fully static shapes, tensors are represented as N-dimensional C arrays, e.g.:

- `const float a[restrict 2][3][4]`
- `float out[restrict 2][3][4]`

Design rules:

- The array rank matches the ONNX tensor rank.
- Each dimension size is a compile-time constant.
- Accesses in kernels are explicit index expressions, enabling straight-line
  loop nests and predictable memory accesses.
- The first array dimension is typically `restrict`-qualified by default to
  express a no-aliasing intent for different tensor parameters. Do not pass
  overlapping storage for two different `restrict` parameters (undefined
  behavior); disable via `--no-restrict-arrays` if needed. Reference:
  https://en.cppreference.com/w/c/language/restrict

Example:

```c
static inline void node0_add(const float input0[2][3][4],
                             const float input1[2][3][4],
                             float output[2][3][4]) {
    for (idx_t i0 = 0; i0 < 2; ++i0) {
        for (idx_t i1 = 0; i1 < 3; ++i1) {
            for (idx_t i2 = 0; i2 < 4; ++i2) {
                output[i0][i1][i2] = input0[i0][i1][i2] + input1[i0][i1][i2];
            }
        }
    }
}
```

### Dynamic dimensions: C99 VLAs (variable-length arrays)

When the model contains symbolic dimensions (dim params), the generator can emit
signatures using C99 VLAs.

Example shape `(N, C)` becomes:

- `void dynamic_dims_model(int N, int C, const float x[restrict N][C], float out[restrict N][C]);`

Example call-site:

```c
// Generated by emx-onnx-cgen:
void dynamic_dims_model(int N, int C,
                        const float x[restrict N][C],
                        float out[restrict N][C]);

void run_dynamic(int N, int C) {
    float x[N][C];   // VLA
    float out[N][C]; // VLA
    // Fill x...
    dynamic_dims_model(N, C, x, out);
}
```

Rules:

- VLA extent parameters are emitted *before* the VLA parameters in the function
  signature so that the array types are valid C.
- Kernels that operate on dynamic shapes also receive the VLA extents.

Constraints:

- This relies on C99 (or later) VLA support in the target compiler.
- Shapes still need to be consistent at runtime; the generated code does not
  perform extensive runtime shape validation.

Reference: https://en.cppreference.com/w/c/language/array

## Loop Nests and Indexing

Computation is emitted as explicit loop nests over the tensor indices.

Conventions:

- Loop indices use `idx_t` (default: `int32_t`; overridable by defining `idx_t`
  before including/compiling the generated translation unit).
- Loop bounds are exact extents (static constants or VLA parameters).
- The innermost loop performs the elementwise operation or accumulation step.

This makes control flow deterministic and easy to inspect, and it avoids hidden
dispatch or vector intrinsics in the generated code.

## Weights and Constants

There are three relevant modes for constants/weights:

1. Embedded constants (default for smaller models):
   - Constant tensors are emitted as `static const` arrays directly in `<out>.c`.
2. Split constants (`--emit-data-file`):
   - `<out>.c` contains `extern` declarations.
   - `<out>_data.c` contains the definitions.
3. External weight loading (`--large-weight-threshold`):
   - Large constants are stored in `<model_name>.bin`.
   - The generated `<model_name>_load()` populates weight arrays from the file.

Implementation details:

- External weight arrays are typically emitted as global arrays (not `const`),
  because they are initialized at runtime by the loader.
- The `.bin` layout is the deterministic concatenation of the selected weight
  tensors in the generator's stable order; the loader reads them back in the
  same order using `fread`.

Example call-site with external weights:

```c
// Generated by emx-onnx-cgen:
_Bool large_weight_model_load(const char *path);
void large_weight_model(const float in0[restrict 2][3], float out[restrict 2][3]);

int main(void) {
    if (!large_weight_model_load("large_weight_model.bin")) {
        return 1;
    }
    float in0[2][3] = {0};
    float out[2][3];
    large_weight_model(in0, out);
    return 0;
}
```

## Temporaries and Memory Discipline

Temporaries (intermediate tensors) are allocated as local arrays inside the
model entrypoint by default.

Large temporaries:

- If a temporary exceeds `--large-temp-threshold`, it may be emitted as `static`
  storage inside the entrypoint to avoid large stack usage (see
  [`tests/golden/large_temp_static_model.c`](../tests/golden/large_temp_static_model.c)).

No dynamic allocation:

- Generated code avoids `malloc` / `free`.
- Memory layout is explicit, visible in the generated source, and stable.

## String Tensors

String tensors are represented as fixed-size character arrays (a "tensor of
fixed-size, `'\0'`-terminated C strings"):

- `char x[...][EMX_STRING_MAX_LEN]`

`EMX_STRING_MAX_LEN` defaults to `256` and can be overridden at compile time by
defining the macro before compiling the generated translation unit.

## Includes and Small Support Macros

Includes are minimized and added only as needed:

- `<stdint.h>` is commonly present (types and `idx_t` default).
- `<math.h>`, `<float.h>` appear when scalar helpers need them.
- `<string.h>` appears for ops like `Identity` on string tensors.
- `<strings.h>` and `<ctype.h>` may appear for string ops like `StringNormalizer`
  (note: `<strings.h>` is POSIX, not ISO C).
- `<stdbool.h>` appears for `bool` outputs/ops.
- `<stdio.h>` appears in translation units that use the testbench, or when
  external weights are loaded from a file path (loader uses `FILE*` / `fopen` /
  `fread`).

Macros:

- `idx_t`: loop index type; defaults to `int32_t` but can be overridden.
- `EMX_UNUSED`: attribute/helper for unused parameters.
- `EMX_STRING_MAX_LEN`: fixed upper bound for string element storage.

## Optional Testbench Output (`--emit-testbench`, `--testbench-file`)

When `--emit-testbench` is enabled, the generated C file additionally includes:

- A `main()` entrypoint that:
  - initializes inputs (random or file-driven),
  - calls `<model_name>_load(...)` when needed,
  - runs `<model_name>(...)`,
  - prints inputs/outputs as JSON.
- Weak `timer_start()` / `timer_stop()` hooks for integration-level timing.

When `--testbench-file <path>` is set, the testbench is emitted into the given
file instead of being appended to `<out>.c` (and `--emit-testbench` is implied).
The generated testbench file contains forward declarations for the model entry
points and can be compiled and linked together with `<out>.c`.

The JSON output is designed for the Python verification pipeline and uses
hex-float formatting (`%a`) for floating-point values to keep comparisons stable
across platforms and library implementations.
