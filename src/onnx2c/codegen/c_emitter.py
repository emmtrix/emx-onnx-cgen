from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path

from jinja2 import Environment, FileSystemLoader, select_autoescape

from ..errors import CodegenError


@dataclass(frozen=True)
class BinaryOp:
    input0: str
    input1: str
    output: str
    operator: str


@dataclass(frozen=True)
class LoweredModel:
    name: str
    input_names: tuple[str, ...]
    output_name: str
    element_count: int
    ops: tuple[BinaryOp, ...]


class CEmitter:
    def __init__(self, template_dir: Path) -> None:
        self._env = Environment(
            loader=FileSystemLoader(str(template_dir)),
            autoescape=select_autoescape(enabled_extensions=()),
            trim_blocks=True,
            lstrip_blocks=True,
        )

    def emit_model(self, model: LoweredModel) -> str:
        try:
            template = self._env.get_template("binary_op.c.j2")
        except Exception as exc:  # pragma: no cover - template load failure
            raise CodegenError("Failed to load C template") from exc
        temp_map = self._temp_buffers(model)
        resolved_ops = [
            BinaryOp(
                input0=temp_map.get(op.input0, op.input0),
                input1=temp_map.get(op.input1, op.input1),
                output=temp_map.get(op.output, op.output),
                operator=op.operator,
            )
            for op in model.ops
        ]
        operator_fns = "\n\n".join(
            template.render(
                model_name=model.name,
                op_name=f"{model.name}_op{index}",
                input0=op.input0,
                input1=op.input1,
                output=op.output,
                element_count=model.element_count,
                operator=op.operator,
            ).rstrip()
            for index, op in enumerate(resolved_ops)
        )
        wrapper_fn = self._emit_model_wrapper(
            model, resolved_ops, tuple(temp_map.values())
        )
        rendered = "\n".join(
            (
                "// Generated by emx-onnx2c (MVP)",
                "#include <stddef.h>",
                "",
                operator_fns.rstrip(),
                "",
                wrapper_fn,
                "",
            )
        )
        if not rendered.endswith("\n"):
            rendered += "\n"
        return rendered

    def _emit_model_wrapper(
        self,
        model: LoweredModel,
        resolved_ops: list[BinaryOp],
        temp_buffers: tuple[str, ...],
    ) -> str:
        signature = ", ".join(
            f"const float* {name}" for name in model.input_names
        )
        lines = [f"void {model.name}({signature}, float* {model.output_name}) {{"]
        for temp in temp_buffers:
            lines.append(f"    float {temp}[{model.element_count}];")
        for index, op in enumerate(resolved_ops):
            lines.append(
                f"    {model.name}_op{index}({op.input0}, {op.input1}, {op.output});"
            )
        lines.append("}")
        return "\n".join(lines)

    def _temp_buffers(self, model: LoweredModel) -> dict[str, str]:
        intermediates = [
            op.output for op in model.ops if op.output != model.output_name
        ]
        if not intermediates:
            return {}
        if len(intermediates) == 1:
            return {intermediates[0]: "tmp"}
        return {
            name: f"tmp{index}"
            for index, name in enumerate(intermediates)
        }
